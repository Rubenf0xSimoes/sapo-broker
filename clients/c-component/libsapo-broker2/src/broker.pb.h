// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_broker_2eproto__INCLUDED
#define PROTOBUF_broker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace sapo_broker {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_broker_2eproto();
void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class Atom;
class Atom_Parameter;
class Atom_Header;
class Atom_BrokerMessage;
class Atom_Publish;
class Atom_Poll;
class Atom_Accepted;
class Atom_AcknowledgeMessage;
class Atom_Subscribe;
class Atom_Unsubscribe;
class Atom_Notification;
class Atom_Fault;
class Atom_Ping;
class Atom_Pong;
class Atom_Authentication;
class Atom_Action;

enum Atom_Action_ActionType {
  Atom_Action_ActionType_PUBLISH = 0,
  Atom_Action_ActionType_POLL = 1,
  Atom_Action_ActionType_ACCEPTED = 2,
  Atom_Action_ActionType_ACKNOWLEDGE_MESSAGE = 3,
  Atom_Action_ActionType_SUBSCRIBE = 4,
  Atom_Action_ActionType_UNSUBSCRIBE = 5,
  Atom_Action_ActionType_NOTIFICATION = 6,
  Atom_Action_ActionType_FAULT = 7,
  Atom_Action_ActionType_PING = 8,
  Atom_Action_ActionType_PONG = 9,
  Atom_Action_ActionType_AUTH = 10
};
const ::google::protobuf::EnumDescriptor* Atom_Action_ActionType_descriptor();
bool Atom_Action_ActionType_IsValid(int value);
const Atom_Action_ActionType Atom_Action_ActionType_ActionType_MIN = Atom_Action_ActionType_PUBLISH;
const Atom_Action_ActionType Atom_Action_ActionType_ActionType_MAX = Atom_Action_ActionType_AUTH;

enum Atom_DestinationType {
  Atom_DestinationType_TOPIC = 0,
  Atom_DestinationType_QUEUE = 1,
  Atom_DestinationType_VIRTUAL_QUEUE = 2
};
const ::google::protobuf::EnumDescriptor* Atom_DestinationType_descriptor();
bool Atom_DestinationType_IsValid(int value);
const Atom_DestinationType Atom_DestinationType_DestinationType_MIN = Atom_DestinationType_TOPIC;
const Atom_DestinationType Atom_DestinationType_DestinationType_MAX = Atom_DestinationType_VIRTUAL_QUEUE;

// ===================================================================

class Atom_Parameter : public ::google::protobuf::Message {
 public:
  Atom_Parameter();
  virtual ~Atom_Parameter();
  
  Atom_Parameter(const Atom_Parameter& from);
  
  inline Atom_Parameter& operator=(const Atom_Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Parameter& default_instance();
  void Swap(Atom_Parameter* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Parameter& from);
  void MergeFrom(const Atom_Parameter& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline ::std::string* mutable_value();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Header : public ::google::protobuf::Message {
 public:
  Atom_Header();
  virtual ~Atom_Header();
  
  Atom_Header(const Atom_Header& from);
  
  inline Atom_Header& operator=(const Atom_Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Header& default_instance();
  void Swap(Atom_Header* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Header& from);
  void MergeFrom(const Atom_Header& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .sapo_broker.Atom.Parameter parameter = 1;
  inline int parameter_size() const;
  inline void clear_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::sapo_broker::Atom_Parameter >& parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::sapo_broker::Atom_Parameter >* mutable_parameter();
  inline const ::sapo_broker::Atom_Parameter& parameter(int index) const;
  inline ::sapo_broker::Atom_Parameter* mutable_parameter(int index);
  inline ::sapo_broker::Atom_Parameter* add_parameter();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::sapo_broker::Atom_Parameter > parameter_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Header* default_instance_;
};
// -------------------------------------------------------------------

class Atom_BrokerMessage : public ::google::protobuf::Message {
 public:
  Atom_BrokerMessage();
  virtual ~Atom_BrokerMessage();
  
  Atom_BrokerMessage(const Atom_BrokerMessage& from);
  
  inline Atom_BrokerMessage& operator=(const Atom_BrokerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_BrokerMessage& default_instance();
  void Swap(Atom_BrokerMessage* other);
  
  // implements Message ----------------------------------------------
  
  Atom_BrokerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_BrokerMessage& from);
  void MergeFrom(const Atom_BrokerMessage& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline ::std::string* mutable_message_id();
  
  // required bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // optional int64 expiration = 3;
  inline bool has_expiration() const;
  inline void clear_expiration();
  inline ::google::protobuf::int64 expiration() const;
  inline void set_expiration(::google::protobuf::int64 value);
  
  // optional int64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* message_id_;
  static const ::std::string _default_message_id_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  ::google::protobuf::int64 expiration_;
  ::google::protobuf::int64 timestamp_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_BrokerMessage* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Publish : public ::google::protobuf::Message {
 public:
  Atom_Publish();
  virtual ~Atom_Publish();
  
  Atom_Publish(const Atom_Publish& from);
  
  inline Atom_Publish& operator=(const Atom_Publish& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Publish& default_instance();
  void Swap(Atom_Publish* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Publish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Publish& from);
  void MergeFrom(const Atom_Publish& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required .sapo_broker.Atom.DestinationType destination_type = 2;
  inline bool has_destination_type() const;
  inline void clear_destination_type();
  inline ::sapo_broker::Atom_DestinationType destination_type() const;
  inline void set_destination_type(::sapo_broker::Atom_DestinationType value);
  
  // required string destination = 3;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // required .sapo_broker.Atom.BrokerMessage message = 4;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::sapo_broker::Atom_BrokerMessage& message() const;
  inline ::sapo_broker::Atom_BrokerMessage* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  int destination_type_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  ::sapo_broker::Atom_BrokerMessage* message_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Publish* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Poll : public ::google::protobuf::Message {
 public:
  Atom_Poll();
  virtual ~Atom_Poll();
  
  Atom_Poll(const Atom_Poll& from);
  
  inline Atom_Poll& operator=(const Atom_Poll& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Poll& default_instance();
  void Swap(Atom_Poll* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Poll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Poll& from);
  void MergeFrom(const Atom_Poll& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required string destination = 2;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // required int64 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  inline ::google::protobuf::int64 timeout() const;
  inline void set_timeout(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  ::google::protobuf::int64 timeout_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Poll* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Accepted : public ::google::protobuf::Message {
 public:
  Atom_Accepted();
  virtual ~Atom_Accepted();
  
  Atom_Accepted(const Atom_Accepted& from);
  
  inline Atom_Accepted& operator=(const Atom_Accepted& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Accepted& default_instance();
  void Swap(Atom_Accepted* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Accepted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Accepted& from);
  void MergeFrom(const Atom_Accepted& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Accepted* default_instance_;
};
// -------------------------------------------------------------------

class Atom_AcknowledgeMessage : public ::google::protobuf::Message {
 public:
  Atom_AcknowledgeMessage();
  virtual ~Atom_AcknowledgeMessage();
  
  Atom_AcknowledgeMessage(const Atom_AcknowledgeMessage& from);
  
  inline Atom_AcknowledgeMessage& operator=(const Atom_AcknowledgeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_AcknowledgeMessage& default_instance();
  void Swap(Atom_AcknowledgeMessage* other);
  
  // implements Message ----------------------------------------------
  
  Atom_AcknowledgeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_AcknowledgeMessage& from);
  void MergeFrom(const Atom_AcknowledgeMessage& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required string message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline ::std::string* mutable_message_id();
  
  // required string destination = 3;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* message_id_;
  static const ::std::string _default_message_id_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_AcknowledgeMessage* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Subscribe : public ::google::protobuf::Message {
 public:
  Atom_Subscribe();
  virtual ~Atom_Subscribe();
  
  Atom_Subscribe(const Atom_Subscribe& from);
  
  inline Atom_Subscribe& operator=(const Atom_Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Subscribe& default_instance();
  void Swap(Atom_Subscribe* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Subscribe& from);
  void MergeFrom(const Atom_Subscribe& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required string destination = 2;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // required .sapo_broker.Atom.DestinationType destination_type = 3;
  inline bool has_destination_type() const;
  inline void clear_destination_type();
  inline ::sapo_broker::Atom_DestinationType destination_type() const;
  inline void set_destination_type(::sapo_broker::Atom_DestinationType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  int destination_type_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Unsubscribe : public ::google::protobuf::Message {
 public:
  Atom_Unsubscribe();
  virtual ~Atom_Unsubscribe();
  
  Atom_Unsubscribe(const Atom_Unsubscribe& from);
  
  inline Atom_Unsubscribe& operator=(const Atom_Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Unsubscribe& default_instance();
  void Swap(Atom_Unsubscribe* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Unsubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Unsubscribe& from);
  void MergeFrom(const Atom_Unsubscribe& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required string destination = 2;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // required .sapo_broker.Atom.DestinationType destination_type = 3;
  inline bool has_destination_type() const;
  inline void clear_destination_type();
  inline ::sapo_broker::Atom_DestinationType destination_type() const;
  inline void set_destination_type(::sapo_broker::Atom_DestinationType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  int destination_type_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Unsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Notification : public ::google::protobuf::Message {
 public:
  Atom_Notification();
  virtual ~Atom_Notification();
  
  Atom_Notification(const Atom_Notification& from);
  
  inline Atom_Notification& operator=(const Atom_Notification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Notification& default_instance();
  void Swap(Atom_Notification* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Notification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Notification& from);
  void MergeFrom(const Atom_Notification& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string destination = 1;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // required string subscription = 2;
  inline bool has_subscription() const;
  inline void clear_subscription();
  inline const ::std::string& subscription() const;
  inline void set_subscription(const ::std::string& value);
  inline void set_subscription(const char* value);
  inline ::std::string* mutable_subscription();
  
  // required .sapo_broker.Atom.DestinationType destination_type = 3;
  inline bool has_destination_type() const;
  inline void clear_destination_type();
  inline ::sapo_broker::Atom_DestinationType destination_type() const;
  inline void set_destination_type(::sapo_broker::Atom_DestinationType value);
  
  // required .sapo_broker.Atom.BrokerMessage message = 4;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::sapo_broker::Atom_BrokerMessage& message() const;
  inline ::sapo_broker::Atom_BrokerMessage* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  ::std::string* subscription_;
  static const ::std::string _default_subscription_;
  int destination_type_;
  ::sapo_broker::Atom_BrokerMessage* message_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Notification* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Fault : public ::google::protobuf::Message {
 public:
  Atom_Fault();
  virtual ~Atom_Fault();
  
  Atom_Fault(const Atom_Fault& from);
  
  inline Atom_Fault& operator=(const Atom_Fault& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Fault& default_instance();
  void Swap(Atom_Fault* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Fault* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Fault& from);
  void MergeFrom(const Atom_Fault& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // required string fault_code = 2;
  inline bool has_fault_code() const;
  inline void clear_fault_code();
  inline const ::std::string& fault_code() const;
  inline void set_fault_code(const ::std::string& value);
  inline void set_fault_code(const char* value);
  inline ::std::string* mutable_fault_code();
  
  // required string fault_message = 3;
  inline bool has_fault_message() const;
  inline void clear_fault_message();
  inline const ::std::string& fault_message() const;
  inline void set_fault_message(const ::std::string& value);
  inline void set_fault_message(const char* value);
  inline ::std::string* mutable_fault_message();
  
  // optional string fault_detail = 4;
  inline bool has_fault_detail() const;
  inline void clear_fault_detail();
  inline const ::std::string& fault_detail() const;
  inline void set_fault_detail(const ::std::string& value);
  inline void set_fault_detail(const char* value);
  inline ::std::string* mutable_fault_detail();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* fault_code_;
  static const ::std::string _default_fault_code_;
  ::std::string* fault_message_;
  static const ::std::string _default_fault_message_;
  ::std::string* fault_detail_;
  static const ::std::string _default_fault_detail_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Fault* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Ping : public ::google::protobuf::Message {
 public:
  Atom_Ping();
  virtual ~Atom_Ping();
  
  Atom_Ping(const Atom_Ping& from);
  
  inline Atom_Ping& operator=(const Atom_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Ping& default_instance();
  void Swap(Atom_Ping* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Ping& from);
  void MergeFrom(const Atom_Ping& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Ping* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Pong : public ::google::protobuf::Message {
 public:
  Atom_Pong();
  virtual ~Atom_Pong();
  
  Atom_Pong(const Atom_Pong& from);
  
  inline Atom_Pong& operator=(const Atom_Pong& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Pong& default_instance();
  void Swap(Atom_Pong* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Pong& from);
  void MergeFrom(const Atom_Pong& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Pong* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Authentication : public ::google::protobuf::Message {
 public:
  Atom_Authentication();
  virtual ~Atom_Authentication();
  
  Atom_Authentication(const Atom_Authentication& from);
  
  inline Atom_Authentication& operator=(const Atom_Authentication& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Authentication& default_instance();
  void Swap(Atom_Authentication* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Authentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Authentication& from);
  void MergeFrom(const Atom_Authentication& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  inline const ::std::string& action_id() const;
  inline void set_action_id(const ::std::string& value);
  inline void set_action_id(const char* value);
  inline ::std::string* mutable_action_id();
  
  // optional string authentication_type = 2;
  inline bool has_authentication_type() const;
  inline void clear_authentication_type();
  inline const ::std::string& authentication_type() const;
  inline void set_authentication_type(const ::std::string& value);
  inline void set_authentication_type(const char* value);
  inline ::std::string* mutable_authentication_type();
  
  // required bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  
  // optional string user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline ::std::string* mutable_user_id();
  
  // repeated string role = 5;
  inline int role_size() const;
  inline void clear_role();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& role() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_role();
  inline const ::std::string& role(int index) const;
  inline ::std::string* mutable_role(int index);
  inline void set_role(int index, const ::std::string& value);
  inline void set_role(int index, const char* value);
  inline ::std::string* add_role();
  inline void add_role(const ::std::string& value);
  inline void add_role(const char* value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_id_;
  static const ::std::string _default_action_id_;
  ::std::string* authentication_type_;
  static const ::std::string _default_authentication_type_;
  ::std::string* token_;
  static const ::std::string _default_token_;
  ::std::string* user_id_;
  static const ::std::string _default_user_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> role_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Authentication* default_instance_;
};
// -------------------------------------------------------------------

class Atom_Action : public ::google::protobuf::Message {
 public:
  Atom_Action();
  virtual ~Atom_Action();
  
  Atom_Action(const Atom_Action& from);
  
  inline Atom_Action& operator=(const Atom_Action& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom_Action& default_instance();
  void Swap(Atom_Action* other);
  
  // implements Message ----------------------------------------------
  
  Atom_Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom_Action& from);
  void MergeFrom(const Atom_Action& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Atom_Action_ActionType ActionType;
  static const ActionType PUBLISH = Atom_Action_ActionType_PUBLISH;
  static const ActionType POLL = Atom_Action_ActionType_POLL;
  static const ActionType ACCEPTED = Atom_Action_ActionType_ACCEPTED;
  static const ActionType ACKNOWLEDGE_MESSAGE = Atom_Action_ActionType_ACKNOWLEDGE_MESSAGE;
  static const ActionType SUBSCRIBE = Atom_Action_ActionType_SUBSCRIBE;
  static const ActionType UNSUBSCRIBE = Atom_Action_ActionType_UNSUBSCRIBE;
  static const ActionType NOTIFICATION = Atom_Action_ActionType_NOTIFICATION;
  static const ActionType FAULT = Atom_Action_ActionType_FAULT;
  static const ActionType PING = Atom_Action_ActionType_PING;
  static const ActionType PONG = Atom_Action_ActionType_PONG;
  static const ActionType AUTH = Atom_Action_ActionType_AUTH;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Atom_Action_ActionType_descriptor();
  }
  static inline bool ActionType_IsValid(int value) {
    return Atom_Action_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Atom_Action_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Atom_Action_ActionType_ActionType_MAX;
  
  // accessors -------------------------------------------------------
  
  // optional .sapo_broker.Atom.Publish publish = 1;
  inline bool has_publish() const;
  inline void clear_publish();
  inline const ::sapo_broker::Atom_Publish& publish() const;
  inline ::sapo_broker::Atom_Publish* mutable_publish();
  
  // optional .sapo_broker.Atom.Poll poll = 2;
  inline bool has_poll() const;
  inline void clear_poll();
  inline const ::sapo_broker::Atom_Poll& poll() const;
  inline ::sapo_broker::Atom_Poll* mutable_poll();
  
  // optional .sapo_broker.Atom.Accepted accepted = 3;
  inline bool has_accepted() const;
  inline void clear_accepted();
  inline const ::sapo_broker::Atom_Accepted& accepted() const;
  inline ::sapo_broker::Atom_Accepted* mutable_accepted();
  
  // optional .sapo_broker.Atom.AcknowledgeMessage ack_message = 4;
  inline bool has_ack_message() const;
  inline void clear_ack_message();
  inline const ::sapo_broker::Atom_AcknowledgeMessage& ack_message() const;
  inline ::sapo_broker::Atom_AcknowledgeMessage* mutable_ack_message();
  
  // optional .sapo_broker.Atom.Subscribe subscribe = 5;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  inline const ::sapo_broker::Atom_Subscribe& subscribe() const;
  inline ::sapo_broker::Atom_Subscribe* mutable_subscribe();
  
  // optional .sapo_broker.Atom.Unsubscribe unsubscribe = 6;
  inline bool has_unsubscribe() const;
  inline void clear_unsubscribe();
  inline const ::sapo_broker::Atom_Unsubscribe& unsubscribe() const;
  inline ::sapo_broker::Atom_Unsubscribe* mutable_unsubscribe();
  
  // optional .sapo_broker.Atom.Notification notification = 7;
  inline bool has_notification() const;
  inline void clear_notification();
  inline const ::sapo_broker::Atom_Notification& notification() const;
  inline ::sapo_broker::Atom_Notification* mutable_notification();
  
  // optional .sapo_broker.Atom.Fault fault = 8;
  inline bool has_fault() const;
  inline void clear_fault();
  inline const ::sapo_broker::Atom_Fault& fault() const;
  inline ::sapo_broker::Atom_Fault* mutable_fault();
  
  // optional .sapo_broker.Atom.Ping ping = 9;
  inline bool has_ping() const;
  inline void clear_ping();
  inline const ::sapo_broker::Atom_Ping& ping() const;
  inline ::sapo_broker::Atom_Ping* mutable_ping();
  
  // optional .sapo_broker.Atom.Pong pong = 10;
  inline bool has_pong() const;
  inline void clear_pong();
  inline const ::sapo_broker::Atom_Pong& pong() const;
  inline ::sapo_broker::Atom_Pong* mutable_pong();
  
  // optional .sapo_broker.Atom.Authentication auth = 11;
  inline bool has_auth() const;
  inline void clear_auth();
  inline const ::sapo_broker::Atom_Authentication& auth() const;
  inline ::sapo_broker::Atom_Authentication* mutable_auth();
  
  // required .sapo_broker.Atom.Action.ActionType action_type = 12;
  inline bool has_action_type() const;
  inline void clear_action_type();
  inline ::sapo_broker::Atom_Action_ActionType action_type() const;
  inline void set_action_type(::sapo_broker::Atom_Action_ActionType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sapo_broker::Atom_Publish* publish_;
  ::sapo_broker::Atom_Poll* poll_;
  ::sapo_broker::Atom_Accepted* accepted_;
  ::sapo_broker::Atom_AcknowledgeMessage* ack_message_;
  ::sapo_broker::Atom_Subscribe* subscribe_;
  ::sapo_broker::Atom_Unsubscribe* unsubscribe_;
  ::sapo_broker::Atom_Notification* notification_;
  ::sapo_broker::Atom_Fault* fault_;
  ::sapo_broker::Atom_Ping* ping_;
  ::sapo_broker::Atom_Pong* pong_;
  ::sapo_broker::Atom_Authentication* auth_;
  int action_type_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom_Action* default_instance_;
};
// -------------------------------------------------------------------

class Atom : public ::google::protobuf::Message {
 public:
  Atom();
  virtual ~Atom();
  
  Atom(const Atom& from);
  
  inline Atom& operator=(const Atom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Atom& default_instance();
  void Swap(Atom* other);
  
  // implements Message ----------------------------------------------
  
  Atom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Atom& from);
  void MergeFrom(const Atom& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Atom_Parameter Parameter;
  typedef Atom_Header Header;
  typedef Atom_BrokerMessage BrokerMessage;
  typedef Atom_Publish Publish;
  typedef Atom_Poll Poll;
  typedef Atom_Accepted Accepted;
  typedef Atom_AcknowledgeMessage AcknowledgeMessage;
  typedef Atom_Subscribe Subscribe;
  typedef Atom_Unsubscribe Unsubscribe;
  typedef Atom_Notification Notification;
  typedef Atom_Fault Fault;
  typedef Atom_Ping Ping;
  typedef Atom_Pong Pong;
  typedef Atom_Authentication Authentication;
  typedef Atom_Action Action;
  
  typedef Atom_DestinationType DestinationType;
  static const DestinationType TOPIC = Atom_DestinationType_TOPIC;
  static const DestinationType QUEUE = Atom_DestinationType_QUEUE;
  static const DestinationType VIRTUAL_QUEUE = Atom_DestinationType_VIRTUAL_QUEUE;
  static inline const ::google::protobuf::EnumDescriptor*
  DestinationType_descriptor() {
    return Atom_DestinationType_descriptor();
  }
  static inline bool DestinationType_IsValid(int value) {
    return Atom_DestinationType_IsValid(value);
  }
  static const DestinationType DestinationType_MIN =
    Atom_DestinationType_DestinationType_MIN;
  static const DestinationType DestinationType_MAX =
    Atom_DestinationType_DestinationType_MAX;
  
  // accessors -------------------------------------------------------
  
  // optional .sapo_broker.Atom.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::sapo_broker::Atom_Header& header() const;
  inline ::sapo_broker::Atom_Header* mutable_header();
  
  // required .sapo_broker.Atom.Action action = 2;
  inline bool has_action() const;
  inline void clear_action();
  inline const ::sapo_broker::Atom_Action& action() const;
  inline ::sapo_broker::Atom_Action* mutable_action();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sapo_broker::Atom_Header* header_;
  ::sapo_broker::Atom_Action* action_;
  friend void protobuf_BuildDesc_broker_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Atom* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Atom_Parameter

// required string name = 1;
inline bool Atom_Parameter::has_name() const {
  return _has_bit(0);
}
inline void Atom_Parameter::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Parameter::name() const {
  return *name_;
}
inline void Atom_Parameter::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Atom_Parameter::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* Atom_Parameter::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string value = 2;
inline bool Atom_Parameter::has_value() const {
  return _has_bit(1);
}
inline void Atom_Parameter::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Parameter::value() const {
  return *value_;
}
inline void Atom_Parameter::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Atom_Parameter::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline ::std::string* Atom_Parameter::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// Atom_Header

// repeated .sapo_broker.Atom.Parameter parameter = 1;
inline int Atom_Header::parameter_size() const {
  return parameter_.size();
}
inline void Atom_Header::clear_parameter() {
  parameter_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sapo_broker::Atom_Parameter >&
Atom_Header::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::sapo_broker::Atom_Parameter >*
Atom_Header::mutable_parameter() {
  return &parameter_;
}
inline const ::sapo_broker::Atom_Parameter& Atom_Header::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::sapo_broker::Atom_Parameter* Atom_Header::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::sapo_broker::Atom_Parameter* Atom_Header::add_parameter() {
  return parameter_.Add();
}

// -------------------------------------------------------------------

// Atom_BrokerMessage

// optional string message_id = 1;
inline bool Atom_BrokerMessage::has_message_id() const {
  return _has_bit(0);
}
inline void Atom_BrokerMessage::clear_message_id() {
  if (message_id_ != &_default_message_id_) {
    message_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_BrokerMessage::message_id() const {
  return *message_id_;
}
inline void Atom_BrokerMessage::set_message_id(const ::std::string& value) {
  _set_bit(0);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void Atom_BrokerMessage::set_message_id(const char* value) {
  _set_bit(0);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline ::std::string* Atom_BrokerMessage::mutable_message_id() {
  _set_bit(0);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}

// required bytes payload = 2;
inline bool Atom_BrokerMessage::has_payload() const {
  return _has_bit(1);
}
inline void Atom_BrokerMessage::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_BrokerMessage::payload() const {
  return *payload_;
}
inline void Atom_BrokerMessage::set_payload(const ::std::string& value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Atom_BrokerMessage::set_payload(const char* value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Atom_BrokerMessage::set_payload(const void* value, size_t size) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Atom_BrokerMessage::mutable_payload() {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// optional int64 expiration = 3;
inline bool Atom_BrokerMessage::has_expiration() const {
  return _has_bit(2);
}
inline void Atom_BrokerMessage::clear_expiration() {
  expiration_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 Atom_BrokerMessage::expiration() const {
  return expiration_;
}
inline void Atom_BrokerMessage::set_expiration(::google::protobuf::int64 value) {
  _set_bit(2);
  expiration_ = value;
}

// optional int64 timestamp = 4;
inline bool Atom_BrokerMessage::has_timestamp() const {
  return _has_bit(3);
}
inline void Atom_BrokerMessage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 Atom_BrokerMessage::timestamp() const {
  return timestamp_;
}
inline void Atom_BrokerMessage::set_timestamp(::google::protobuf::int64 value) {
  _set_bit(3);
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Atom_Publish

// optional string action_id = 1;
inline bool Atom_Publish::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Publish::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Publish::action_id() const {
  return *action_id_;
}
inline void Atom_Publish::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Publish::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Publish::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required .sapo_broker.Atom.DestinationType destination_type = 2;
inline bool Atom_Publish::has_destination_type() const {
  return _has_bit(1);
}
inline void Atom_Publish::clear_destination_type() {
  destination_type_ = 0;
  _clear_bit(1);
}
inline ::sapo_broker::Atom_DestinationType Atom_Publish::destination_type() const {
  return static_cast< ::sapo_broker::Atom_DestinationType >(destination_type_);
}
inline void Atom_Publish::set_destination_type(::sapo_broker::Atom_DestinationType value) {
  GOOGLE_DCHECK(::sapo_broker::Atom_DestinationType_IsValid(value));
  _set_bit(1);
  destination_type_ = value;
}

// required string destination = 3;
inline bool Atom_Publish::has_destination() const {
  return _has_bit(2);
}
inline void Atom_Publish::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Atom_Publish::destination() const {
  return *destination_;
}
inline void Atom_Publish::set_destination(const ::std::string& value) {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_Publish::set_destination(const char* value) {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_Publish::mutable_destination() {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// required .sapo_broker.Atom.BrokerMessage message = 4;
inline bool Atom_Publish::has_message() const {
  return _has_bit(3);
}
inline void Atom_Publish::clear_message() {
  if (message_ != NULL) message_->::sapo_broker::Atom_BrokerMessage::Clear();
  _clear_bit(3);
}
inline const ::sapo_broker::Atom_BrokerMessage& Atom_Publish::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::sapo_broker::Atom_BrokerMessage* Atom_Publish::mutable_message() {
  _set_bit(3);
  if (message_ == NULL) message_ = new ::sapo_broker::Atom_BrokerMessage;
  return message_;
}

// -------------------------------------------------------------------

// Atom_Poll

// optional string action_id = 1;
inline bool Atom_Poll::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Poll::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Poll::action_id() const {
  return *action_id_;
}
inline void Atom_Poll::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Poll::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Poll::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required string destination = 2;
inline bool Atom_Poll::has_destination() const {
  return _has_bit(1);
}
inline void Atom_Poll::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Poll::destination() const {
  return *destination_;
}
inline void Atom_Poll::set_destination(const ::std::string& value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_Poll::set_destination(const char* value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_Poll::mutable_destination() {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// required int64 timeout = 3;
inline bool Atom_Poll::has_timeout() const {
  return _has_bit(2);
}
inline void Atom_Poll::clear_timeout() {
  timeout_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 Atom_Poll::timeout() const {
  return timeout_;
}
inline void Atom_Poll::set_timeout(::google::protobuf::int64 value) {
  _set_bit(2);
  timeout_ = value;
}

// -------------------------------------------------------------------

// Atom_Accepted

// required string action_id = 1;
inline bool Atom_Accepted::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Accepted::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Accepted::action_id() const {
  return *action_id_;
}
inline void Atom_Accepted::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Accepted::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Accepted::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// -------------------------------------------------------------------

// Atom_AcknowledgeMessage

// optional string action_id = 1;
inline bool Atom_AcknowledgeMessage::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_AcknowledgeMessage::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_AcknowledgeMessage::action_id() const {
  return *action_id_;
}
inline void Atom_AcknowledgeMessage::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_AcknowledgeMessage::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_AcknowledgeMessage::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required string message_id = 2;
inline bool Atom_AcknowledgeMessage::has_message_id() const {
  return _has_bit(1);
}
inline void Atom_AcknowledgeMessage::clear_message_id() {
  if (message_id_ != &_default_message_id_) {
    message_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_AcknowledgeMessage::message_id() const {
  return *message_id_;
}
inline void Atom_AcknowledgeMessage::set_message_id(const ::std::string& value) {
  _set_bit(1);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void Atom_AcknowledgeMessage::set_message_id(const char* value) {
  _set_bit(1);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline ::std::string* Atom_AcknowledgeMessage::mutable_message_id() {
  _set_bit(1);
  if (message_id_ == &_default_message_id_) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}

// required string destination = 3;
inline bool Atom_AcknowledgeMessage::has_destination() const {
  return _has_bit(2);
}
inline void Atom_AcknowledgeMessage::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Atom_AcknowledgeMessage::destination() const {
  return *destination_;
}
inline void Atom_AcknowledgeMessage::set_destination(const ::std::string& value) {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_AcknowledgeMessage::set_destination(const char* value) {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_AcknowledgeMessage::mutable_destination() {
  _set_bit(2);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// -------------------------------------------------------------------

// Atom_Subscribe

// optional string action_id = 1;
inline bool Atom_Subscribe::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Subscribe::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Subscribe::action_id() const {
  return *action_id_;
}
inline void Atom_Subscribe::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Subscribe::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Subscribe::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required string destination = 2;
inline bool Atom_Subscribe::has_destination() const {
  return _has_bit(1);
}
inline void Atom_Subscribe::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Subscribe::destination() const {
  return *destination_;
}
inline void Atom_Subscribe::set_destination(const ::std::string& value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_Subscribe::set_destination(const char* value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_Subscribe::mutable_destination() {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// required .sapo_broker.Atom.DestinationType destination_type = 3;
inline bool Atom_Subscribe::has_destination_type() const {
  return _has_bit(2);
}
inline void Atom_Subscribe::clear_destination_type() {
  destination_type_ = 0;
  _clear_bit(2);
}
inline ::sapo_broker::Atom_DestinationType Atom_Subscribe::destination_type() const {
  return static_cast< ::sapo_broker::Atom_DestinationType >(destination_type_);
}
inline void Atom_Subscribe::set_destination_type(::sapo_broker::Atom_DestinationType value) {
  GOOGLE_DCHECK(::sapo_broker::Atom_DestinationType_IsValid(value));
  _set_bit(2);
  destination_type_ = value;
}

// -------------------------------------------------------------------

// Atom_Unsubscribe

// optional string action_id = 1;
inline bool Atom_Unsubscribe::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Unsubscribe::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Unsubscribe::action_id() const {
  return *action_id_;
}
inline void Atom_Unsubscribe::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Unsubscribe::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Unsubscribe::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required string destination = 2;
inline bool Atom_Unsubscribe::has_destination() const {
  return _has_bit(1);
}
inline void Atom_Unsubscribe::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Unsubscribe::destination() const {
  return *destination_;
}
inline void Atom_Unsubscribe::set_destination(const ::std::string& value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_Unsubscribe::set_destination(const char* value) {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_Unsubscribe::mutable_destination() {
  _set_bit(1);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// required .sapo_broker.Atom.DestinationType destination_type = 3;
inline bool Atom_Unsubscribe::has_destination_type() const {
  return _has_bit(2);
}
inline void Atom_Unsubscribe::clear_destination_type() {
  destination_type_ = 0;
  _clear_bit(2);
}
inline ::sapo_broker::Atom_DestinationType Atom_Unsubscribe::destination_type() const {
  return static_cast< ::sapo_broker::Atom_DestinationType >(destination_type_);
}
inline void Atom_Unsubscribe::set_destination_type(::sapo_broker::Atom_DestinationType value) {
  GOOGLE_DCHECK(::sapo_broker::Atom_DestinationType_IsValid(value));
  _set_bit(2);
  destination_type_ = value;
}

// -------------------------------------------------------------------

// Atom_Notification

// required string destination = 1;
inline bool Atom_Notification::has_destination() const {
  return _has_bit(0);
}
inline void Atom_Notification::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Notification::destination() const {
  return *destination_;
}
inline void Atom_Notification::set_destination(const ::std::string& value) {
  _set_bit(0);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void Atom_Notification::set_destination(const char* value) {
  _set_bit(0);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* Atom_Notification::mutable_destination() {
  _set_bit(0);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// required string subscription = 2;
inline bool Atom_Notification::has_subscription() const {
  return _has_bit(1);
}
inline void Atom_Notification::clear_subscription() {
  if (subscription_ != &_default_subscription_) {
    subscription_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Notification::subscription() const {
  return *subscription_;
}
inline void Atom_Notification::set_subscription(const ::std::string& value) {
  _set_bit(1);
  if (subscription_ == &_default_subscription_) {
    subscription_ = new ::std::string;
  }
  subscription_->assign(value);
}
inline void Atom_Notification::set_subscription(const char* value) {
  _set_bit(1);
  if (subscription_ == &_default_subscription_) {
    subscription_ = new ::std::string;
  }
  subscription_->assign(value);
}
inline ::std::string* Atom_Notification::mutable_subscription() {
  _set_bit(1);
  if (subscription_ == &_default_subscription_) {
    subscription_ = new ::std::string;
  }
  return subscription_;
}

// required .sapo_broker.Atom.DestinationType destination_type = 3;
inline bool Atom_Notification::has_destination_type() const {
  return _has_bit(2);
}
inline void Atom_Notification::clear_destination_type() {
  destination_type_ = 0;
  _clear_bit(2);
}
inline ::sapo_broker::Atom_DestinationType Atom_Notification::destination_type() const {
  return static_cast< ::sapo_broker::Atom_DestinationType >(destination_type_);
}
inline void Atom_Notification::set_destination_type(::sapo_broker::Atom_DestinationType value) {
  GOOGLE_DCHECK(::sapo_broker::Atom_DestinationType_IsValid(value));
  _set_bit(2);
  destination_type_ = value;
}

// required .sapo_broker.Atom.BrokerMessage message = 4;
inline bool Atom_Notification::has_message() const {
  return _has_bit(3);
}
inline void Atom_Notification::clear_message() {
  if (message_ != NULL) message_->::sapo_broker::Atom_BrokerMessage::Clear();
  _clear_bit(3);
}
inline const ::sapo_broker::Atom_BrokerMessage& Atom_Notification::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::sapo_broker::Atom_BrokerMessage* Atom_Notification::mutable_message() {
  _set_bit(3);
  if (message_ == NULL) message_ = new ::sapo_broker::Atom_BrokerMessage;
  return message_;
}

// -------------------------------------------------------------------

// Atom_Fault

// optional string action_id = 1;
inline bool Atom_Fault::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Fault::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Fault::action_id() const {
  return *action_id_;
}
inline void Atom_Fault::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Fault::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Fault::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// required string fault_code = 2;
inline bool Atom_Fault::has_fault_code() const {
  return _has_bit(1);
}
inline void Atom_Fault::clear_fault_code() {
  if (fault_code_ != &_default_fault_code_) {
    fault_code_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Fault::fault_code() const {
  return *fault_code_;
}
inline void Atom_Fault::set_fault_code(const ::std::string& value) {
  _set_bit(1);
  if (fault_code_ == &_default_fault_code_) {
    fault_code_ = new ::std::string;
  }
  fault_code_->assign(value);
}
inline void Atom_Fault::set_fault_code(const char* value) {
  _set_bit(1);
  if (fault_code_ == &_default_fault_code_) {
    fault_code_ = new ::std::string;
  }
  fault_code_->assign(value);
}
inline ::std::string* Atom_Fault::mutable_fault_code() {
  _set_bit(1);
  if (fault_code_ == &_default_fault_code_) {
    fault_code_ = new ::std::string;
  }
  return fault_code_;
}

// required string fault_message = 3;
inline bool Atom_Fault::has_fault_message() const {
  return _has_bit(2);
}
inline void Atom_Fault::clear_fault_message() {
  if (fault_message_ != &_default_fault_message_) {
    fault_message_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Atom_Fault::fault_message() const {
  return *fault_message_;
}
inline void Atom_Fault::set_fault_message(const ::std::string& value) {
  _set_bit(2);
  if (fault_message_ == &_default_fault_message_) {
    fault_message_ = new ::std::string;
  }
  fault_message_->assign(value);
}
inline void Atom_Fault::set_fault_message(const char* value) {
  _set_bit(2);
  if (fault_message_ == &_default_fault_message_) {
    fault_message_ = new ::std::string;
  }
  fault_message_->assign(value);
}
inline ::std::string* Atom_Fault::mutable_fault_message() {
  _set_bit(2);
  if (fault_message_ == &_default_fault_message_) {
    fault_message_ = new ::std::string;
  }
  return fault_message_;
}

// optional string fault_detail = 4;
inline bool Atom_Fault::has_fault_detail() const {
  return _has_bit(3);
}
inline void Atom_Fault::clear_fault_detail() {
  if (fault_detail_ != &_default_fault_detail_) {
    fault_detail_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Atom_Fault::fault_detail() const {
  return *fault_detail_;
}
inline void Atom_Fault::set_fault_detail(const ::std::string& value) {
  _set_bit(3);
  if (fault_detail_ == &_default_fault_detail_) {
    fault_detail_ = new ::std::string;
  }
  fault_detail_->assign(value);
}
inline void Atom_Fault::set_fault_detail(const char* value) {
  _set_bit(3);
  if (fault_detail_ == &_default_fault_detail_) {
    fault_detail_ = new ::std::string;
  }
  fault_detail_->assign(value);
}
inline ::std::string* Atom_Fault::mutable_fault_detail() {
  _set_bit(3);
  if (fault_detail_ == &_default_fault_detail_) {
    fault_detail_ = new ::std::string;
  }
  return fault_detail_;
}

// -------------------------------------------------------------------

// Atom_Ping

// required string action_id = 1;
inline bool Atom_Ping::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Ping::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Ping::action_id() const {
  return *action_id_;
}
inline void Atom_Ping::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Ping::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Ping::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// -------------------------------------------------------------------

// Atom_Pong

// required string action_id = 1;
inline bool Atom_Pong::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Pong::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Pong::action_id() const {
  return *action_id_;
}
inline void Atom_Pong::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Pong::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Pong::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// -------------------------------------------------------------------

// Atom_Authentication

// optional string action_id = 1;
inline bool Atom_Authentication::has_action_id() const {
  return _has_bit(0);
}
inline void Atom_Authentication::clear_action_id() {
  if (action_id_ != &_default_action_id_) {
    action_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Atom_Authentication::action_id() const {
  return *action_id_;
}
inline void Atom_Authentication::set_action_id(const ::std::string& value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline void Atom_Authentication::set_action_id(const char* value) {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  action_id_->assign(value);
}
inline ::std::string* Atom_Authentication::mutable_action_id() {
  _set_bit(0);
  if (action_id_ == &_default_action_id_) {
    action_id_ = new ::std::string;
  }
  return action_id_;
}

// optional string authentication_type = 2;
inline bool Atom_Authentication::has_authentication_type() const {
  return _has_bit(1);
}
inline void Atom_Authentication::clear_authentication_type() {
  if (authentication_type_ != &_default_authentication_type_) {
    authentication_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Atom_Authentication::authentication_type() const {
  return *authentication_type_;
}
inline void Atom_Authentication::set_authentication_type(const ::std::string& value) {
  _set_bit(1);
  if (authentication_type_ == &_default_authentication_type_) {
    authentication_type_ = new ::std::string;
  }
  authentication_type_->assign(value);
}
inline void Atom_Authentication::set_authentication_type(const char* value) {
  _set_bit(1);
  if (authentication_type_ == &_default_authentication_type_) {
    authentication_type_ = new ::std::string;
  }
  authentication_type_->assign(value);
}
inline ::std::string* Atom_Authentication::mutable_authentication_type() {
  _set_bit(1);
  if (authentication_type_ == &_default_authentication_type_) {
    authentication_type_ = new ::std::string;
  }
  return authentication_type_;
}

// required bytes token = 3;
inline bool Atom_Authentication::has_token() const {
  return _has_bit(2);
}
inline void Atom_Authentication::clear_token() {
  if (token_ != &_default_token_) {
    token_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Atom_Authentication::token() const {
  return *token_;
}
inline void Atom_Authentication::set_token(const ::std::string& value) {
  _set_bit(2);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Atom_Authentication::set_token(const char* value) {
  _set_bit(2);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Atom_Authentication::set_token(const void* value, size_t size) {
  _set_bit(2);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Atom_Authentication::mutable_token() {
  _set_bit(2);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  return token_;
}

// optional string user_id = 4;
inline bool Atom_Authentication::has_user_id() const {
  return _has_bit(3);
}
inline void Atom_Authentication::clear_user_id() {
  if (user_id_ != &_default_user_id_) {
    user_id_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Atom_Authentication::user_id() const {
  return *user_id_;
}
inline void Atom_Authentication::set_user_id(const ::std::string& value) {
  _set_bit(3);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void Atom_Authentication::set_user_id(const char* value) {
  _set_bit(3);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline ::std::string* Atom_Authentication::mutable_user_id() {
  _set_bit(3);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}

// repeated string role = 5;
inline int Atom_Authentication::role_size() const {
  return role_.size();
}
inline void Atom_Authentication::clear_role() {
  role_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Atom_Authentication::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Atom_Authentication::mutable_role() {
  return &role_;
}
inline const ::std::string& Atom_Authentication::role(int index) const {
  return role_.Get(index);
}
inline ::std::string* Atom_Authentication::mutable_role(int index) {
  return role_.Mutable(index);
}
inline void Atom_Authentication::set_role(int index, const ::std::string& value) {
  role_.Mutable(index)->assign(value);
}
inline void Atom_Authentication::set_role(int index, const char* value) {
  role_.Mutable(index)->assign(value);
}
inline ::std::string* Atom_Authentication::add_role() {
  return role_.Add();
}
inline void Atom_Authentication::add_role(const ::std::string& value) {
  role_.Add()->assign(value);
}
inline void Atom_Authentication::add_role(const char* value) {
  role_.Add()->assign(value);
}

// -------------------------------------------------------------------

// Atom_Action

// optional .sapo_broker.Atom.Publish publish = 1;
inline bool Atom_Action::has_publish() const {
  return _has_bit(0);
}
inline void Atom_Action::clear_publish() {
  if (publish_ != NULL) publish_->::sapo_broker::Atom_Publish::Clear();
  _clear_bit(0);
}
inline const ::sapo_broker::Atom_Publish& Atom_Action::publish() const {
  return publish_ != NULL ? *publish_ : *default_instance_->publish_;
}
inline ::sapo_broker::Atom_Publish* Atom_Action::mutable_publish() {
  _set_bit(0);
  if (publish_ == NULL) publish_ = new ::sapo_broker::Atom_Publish;
  return publish_;
}

// optional .sapo_broker.Atom.Poll poll = 2;
inline bool Atom_Action::has_poll() const {
  return _has_bit(1);
}
inline void Atom_Action::clear_poll() {
  if (poll_ != NULL) poll_->::sapo_broker::Atom_Poll::Clear();
  _clear_bit(1);
}
inline const ::sapo_broker::Atom_Poll& Atom_Action::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::sapo_broker::Atom_Poll* Atom_Action::mutable_poll() {
  _set_bit(1);
  if (poll_ == NULL) poll_ = new ::sapo_broker::Atom_Poll;
  return poll_;
}

// optional .sapo_broker.Atom.Accepted accepted = 3;
inline bool Atom_Action::has_accepted() const {
  return _has_bit(2);
}
inline void Atom_Action::clear_accepted() {
  if (accepted_ != NULL) accepted_->::sapo_broker::Atom_Accepted::Clear();
  _clear_bit(2);
}
inline const ::sapo_broker::Atom_Accepted& Atom_Action::accepted() const {
  return accepted_ != NULL ? *accepted_ : *default_instance_->accepted_;
}
inline ::sapo_broker::Atom_Accepted* Atom_Action::mutable_accepted() {
  _set_bit(2);
  if (accepted_ == NULL) accepted_ = new ::sapo_broker::Atom_Accepted;
  return accepted_;
}

// optional .sapo_broker.Atom.AcknowledgeMessage ack_message = 4;
inline bool Atom_Action::has_ack_message() const {
  return _has_bit(3);
}
inline void Atom_Action::clear_ack_message() {
  if (ack_message_ != NULL) ack_message_->::sapo_broker::Atom_AcknowledgeMessage::Clear();
  _clear_bit(3);
}
inline const ::sapo_broker::Atom_AcknowledgeMessage& Atom_Action::ack_message() const {
  return ack_message_ != NULL ? *ack_message_ : *default_instance_->ack_message_;
}
inline ::sapo_broker::Atom_AcknowledgeMessage* Atom_Action::mutable_ack_message() {
  _set_bit(3);
  if (ack_message_ == NULL) ack_message_ = new ::sapo_broker::Atom_AcknowledgeMessage;
  return ack_message_;
}

// optional .sapo_broker.Atom.Subscribe subscribe = 5;
inline bool Atom_Action::has_subscribe() const {
  return _has_bit(4);
}
inline void Atom_Action::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->::sapo_broker::Atom_Subscribe::Clear();
  _clear_bit(4);
}
inline const ::sapo_broker::Atom_Subscribe& Atom_Action::subscribe() const {
  return subscribe_ != NULL ? *subscribe_ : *default_instance_->subscribe_;
}
inline ::sapo_broker::Atom_Subscribe* Atom_Action::mutable_subscribe() {
  _set_bit(4);
  if (subscribe_ == NULL) subscribe_ = new ::sapo_broker::Atom_Subscribe;
  return subscribe_;
}

// optional .sapo_broker.Atom.Unsubscribe unsubscribe = 6;
inline bool Atom_Action::has_unsubscribe() const {
  return _has_bit(5);
}
inline void Atom_Action::clear_unsubscribe() {
  if (unsubscribe_ != NULL) unsubscribe_->::sapo_broker::Atom_Unsubscribe::Clear();
  _clear_bit(5);
}
inline const ::sapo_broker::Atom_Unsubscribe& Atom_Action::unsubscribe() const {
  return unsubscribe_ != NULL ? *unsubscribe_ : *default_instance_->unsubscribe_;
}
inline ::sapo_broker::Atom_Unsubscribe* Atom_Action::mutable_unsubscribe() {
  _set_bit(5);
  if (unsubscribe_ == NULL) unsubscribe_ = new ::sapo_broker::Atom_Unsubscribe;
  return unsubscribe_;
}

// optional .sapo_broker.Atom.Notification notification = 7;
inline bool Atom_Action::has_notification() const {
  return _has_bit(6);
}
inline void Atom_Action::clear_notification() {
  if (notification_ != NULL) notification_->::sapo_broker::Atom_Notification::Clear();
  _clear_bit(6);
}
inline const ::sapo_broker::Atom_Notification& Atom_Action::notification() const {
  return notification_ != NULL ? *notification_ : *default_instance_->notification_;
}
inline ::sapo_broker::Atom_Notification* Atom_Action::mutable_notification() {
  _set_bit(6);
  if (notification_ == NULL) notification_ = new ::sapo_broker::Atom_Notification;
  return notification_;
}

// optional .sapo_broker.Atom.Fault fault = 8;
inline bool Atom_Action::has_fault() const {
  return _has_bit(7);
}
inline void Atom_Action::clear_fault() {
  if (fault_ != NULL) fault_->::sapo_broker::Atom_Fault::Clear();
  _clear_bit(7);
}
inline const ::sapo_broker::Atom_Fault& Atom_Action::fault() const {
  return fault_ != NULL ? *fault_ : *default_instance_->fault_;
}
inline ::sapo_broker::Atom_Fault* Atom_Action::mutable_fault() {
  _set_bit(7);
  if (fault_ == NULL) fault_ = new ::sapo_broker::Atom_Fault;
  return fault_;
}

// optional .sapo_broker.Atom.Ping ping = 9;
inline bool Atom_Action::has_ping() const {
  return _has_bit(8);
}
inline void Atom_Action::clear_ping() {
  if (ping_ != NULL) ping_->::sapo_broker::Atom_Ping::Clear();
  _clear_bit(8);
}
inline const ::sapo_broker::Atom_Ping& Atom_Action::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::sapo_broker::Atom_Ping* Atom_Action::mutable_ping() {
  _set_bit(8);
  if (ping_ == NULL) ping_ = new ::sapo_broker::Atom_Ping;
  return ping_;
}

// optional .sapo_broker.Atom.Pong pong = 10;
inline bool Atom_Action::has_pong() const {
  return _has_bit(9);
}
inline void Atom_Action::clear_pong() {
  if (pong_ != NULL) pong_->::sapo_broker::Atom_Pong::Clear();
  _clear_bit(9);
}
inline const ::sapo_broker::Atom_Pong& Atom_Action::pong() const {
  return pong_ != NULL ? *pong_ : *default_instance_->pong_;
}
inline ::sapo_broker::Atom_Pong* Atom_Action::mutable_pong() {
  _set_bit(9);
  if (pong_ == NULL) pong_ = new ::sapo_broker::Atom_Pong;
  return pong_;
}

// optional .sapo_broker.Atom.Authentication auth = 11;
inline bool Atom_Action::has_auth() const {
  return _has_bit(10);
}
inline void Atom_Action::clear_auth() {
  if (auth_ != NULL) auth_->::sapo_broker::Atom_Authentication::Clear();
  _clear_bit(10);
}
inline const ::sapo_broker::Atom_Authentication& Atom_Action::auth() const {
  return auth_ != NULL ? *auth_ : *default_instance_->auth_;
}
inline ::sapo_broker::Atom_Authentication* Atom_Action::mutable_auth() {
  _set_bit(10);
  if (auth_ == NULL) auth_ = new ::sapo_broker::Atom_Authentication;
  return auth_;
}

// required .sapo_broker.Atom.Action.ActionType action_type = 12;
inline bool Atom_Action::has_action_type() const {
  return _has_bit(11);
}
inline void Atom_Action::clear_action_type() {
  action_type_ = 0;
  _clear_bit(11);
}
inline ::sapo_broker::Atom_Action_ActionType Atom_Action::action_type() const {
  return static_cast< ::sapo_broker::Atom_Action_ActionType >(action_type_);
}
inline void Atom_Action::set_action_type(::sapo_broker::Atom_Action_ActionType value) {
  GOOGLE_DCHECK(::sapo_broker::Atom_Action_ActionType_IsValid(value));
  _set_bit(11);
  action_type_ = value;
}

// -------------------------------------------------------------------

// Atom

// optional .sapo_broker.Atom.Header header = 1;
inline bool Atom::has_header() const {
  return _has_bit(0);
}
inline void Atom::clear_header() {
  if (header_ != NULL) header_->::sapo_broker::Atom_Header::Clear();
  _clear_bit(0);
}
inline const ::sapo_broker::Atom_Header& Atom::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::sapo_broker::Atom_Header* Atom::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::sapo_broker::Atom_Header;
  return header_;
}

// required .sapo_broker.Atom.Action action = 2;
inline bool Atom::has_action() const {
  return _has_bit(1);
}
inline void Atom::clear_action() {
  if (action_ != NULL) action_->::sapo_broker::Atom_Action::Clear();
  _clear_bit(1);
}
inline const ::sapo_broker::Atom_Action& Atom::action() const {
  return action_ != NULL ? *action_ : *default_instance_->action_;
}
inline ::sapo_broker::Atom_Action* Atom::mutable_action() {
  _set_bit(1);
  if (action_ == NULL) action_ = new ::sapo_broker::Atom_Action;
  return action_;
}


}  // namespace sapo_broker
#endif  // PROTOBUF_broker_2eproto__INCLUDED
